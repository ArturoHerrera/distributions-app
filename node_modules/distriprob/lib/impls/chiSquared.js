"use strict";
const continuedFractionSolver_1 = require("./continuedFractionSolver");
const gamma = require("./gamma");
const rf = require("./rootFind");
const async_1 = require("./async");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lowerIncompleteGamma = gamma.lowerIncompleteGamma;
const upperIncompleteGamma = gamma.upperIncompleteGamma;
const lnGamma = gamma.lnGamma;
const rootFind = rf.rootFind;
function pdfSync(x, degreesOfFreedom) {
    if (x <= 0) {
        return 0;
    }
    else {
        let k = degreesOfFreedom;
        let lnNumerator = ((k / 2) - 1) * Math.log(x) - (x / 2);
        let lnDenominator = ((k / 2) * Math.log(2)) + lnGamma(k / 2);
        return Math.exp(lnNumerator - lnDenominator);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, degreesOfFreedom) {
    return async_1.asyncGen([lnGamma, pdfSync], pdfSync, [x, degreesOfFreedom]);
}
exports.pdf = pdf;
function cdfSync(x, degreesOfFreedom, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            return lowerIncompleteGamma(x / 2, degreesOfFreedom / 2);
        }
        else {
            return upperIncompleteGamma(x / 2, degreesOfFreedom / 2);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma
    ], cdfSync, [x, degreesOfFreedom, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, degreesOfFreedom, lowerTail = true) {
    function f(val) {
        return cdfSync(val, degreesOfFreedom);
    }
    function fPrime(val) {
        return pdfSync(val, degreesOfFreedom);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, 1, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        pdfSync,
        cdfSync
    ], quantileSync, [p, degreesOfFreedom, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, degreesOfFreedom, seed, randoms) {
    return random_1.randSync(n, quantileSync, [degreesOfFreedom], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, degreesOfFreedom, seed) {
    return random_1.rand(n, quantileSync, [degreesOfFreedom], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;
