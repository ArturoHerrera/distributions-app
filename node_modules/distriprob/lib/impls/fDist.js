"use strict";
const gamma = require("./gamma");
const beta = require("./beta");
const rf = require("./rootFind");
const async_1 = require("./async");
const random_1 = require("./random");
const continuedFractionSolver_1 = require("./continuedFractionSolver");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lnGamma = gamma.lnGamma;
const lnBeta = beta.lnBeta;
const incompleteBeta = beta.incompleteBeta;
const rootFind = rf.rootFind;
function pdfSync(x, dof1, dof2) {
    if (x <= 0) {
        return 0;
    }
    else {
        const lnNumNum = (dof1 * Math.log(dof1 * x)) + (dof2 * Math.log(dof2));
        const lnNumDenom = (dof1 + dof2) * Math.log((dof1 * x) + dof2);
        const lnNum = 0.5 * (lnNumNum - lnNumDenom);
        const lnDenom = Math.log(x) + lnBeta(dof1 / 2, dof2 / 2);
        return Math.exp(lnNum - lnDenom);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, dof1, dof2) {
    return async_1.asyncGen([beta.lnBeta, gamma.lnGamma,], pdfSync, [x, dof1, dof2]);
}
exports.pdf = pdf;
function cdfSync(x, dof1, dof2, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            return incompleteBeta((dof1 * x) / (dof2 + (dof1 * x)), dof1 / 2, dof2 / 2);
        }
        else {
            return incompleteBeta(dof2 / (dof2 + (dof1 * x)), dof2 / 2, dof1 / 2);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, dof1, dof2, lowerTail = true) {
    return async_1.asyncGen([
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta
    ], cdfSync, [x, dof1, dof2, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, dof1, dof2, lowerTail = true) {
    function f(val) {
        return cdfSync(val, dof1, dof2);
    }
    function fPrime(val) {
        return pdfSync(val, dof1, dof2);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, 1, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, dof1, dof2, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ], quantileSync, [p, dof1, dof2, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, dof1, dof2, seed, randoms) {
    return random_1.randSync(n, quantileSync, [dof1, dof2], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, dof1, dof2, seed) {
    return random_1.rand(n, quantileSync, [dof1, dof2], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;
