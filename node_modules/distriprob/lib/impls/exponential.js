"use strict";
const async_1 = require("./async");
const random_1 = require("./random");
const gamma = require("./gamma");
const cf = require("./continuedFractionSolver");
const rf = require("./rootFind");
const gammaCDF = gamma.gammaCDF;
const rootFind = rf.rootFind;
function pdfSync(x, lambda) {
    if (x < 0) {
        return 0;
    }
    else {
        return lambda * Math.exp((-lambda) * x);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, lambda) {
    return async_1.asyncGen([], pdfSync, [x, lambda]);
}
exports.pdf = pdf;
function cdfSync(x, lambda, lowerTail = true) {
    if (x < 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            const possibleResult = 1 - Math.exp((-lambda) * x);
            if (possibleResult >= 0.1) {
                return possibleResult;
            }
            else {
                return gammaCDF(x, 1, 1 / lambda, true);
            }
        }
        else {
            return Math.exp((-lambda) * x);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, lambda, lowerTail = true) {
    return async_1.asyncGen([
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma
    ], cdfSync, [x, lambda, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, lambda, lowerTail = true) {
    function f(val) {
        return cdfSync(val, lambda, lowerTail);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, lambda);
        }
        else {
            return -pdfSync(val, lambda);
        }
    }
    const mean = 1 / lambda;
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, mean, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, lambda, lowerTail = true) {
    return async_1.asyncGen([
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        cdfSync
    ], quantileSync, [p, lambda, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, lambda, seed, randoms) {
    return random_1.randSync(n, quantileSync, [lambda], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, lambda, seed) {
    return random_1.rand(n, quantileSync, [lambda], seed, [
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;
