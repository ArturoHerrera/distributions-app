"use strict";
const random_1 = require("./random");
"use strict";
function pdfSync(x, lowerSupportBound, upperSupportBound) {
    if (x < lowerSupportBound || x > upperSupportBound) {
        return 0;
    }
    else {
        return 1 / (upperSupportBound - lowerSupportBound);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, lowerSupportBound, upperSupportBound) {
    return Promise.resolve(pdfSync(x, lowerSupportBound, upperSupportBound));
}
exports.pdf = pdf;
function cdfSync(x, lowerSupportBound, upperSupportBound, lowerTail = true) {
    if (x < lowerSupportBound) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if (x > upperSupportBound) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        if (lowerTail) {
            return (x - lowerSupportBound) / (upperSupportBound - lowerSupportBound);
        }
        else {
            return (upperSupportBound - x) / (upperSupportBound - lowerSupportBound);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, lowerSupportBound, upperSupportBound, lowerTail = true) {
    return Promise.resolve(cdfSync(x, lowerSupportBound, upperSupportBound, lowerTail));
}
exports.cdf = cdf;
function quantileSync(p, lowerSupportBound, upperSupportBound, lowerTail = true) {
    if (p === 0) {
        if (lowerTail) {
            return lowerSupportBound;
        }
        else {
            return upperSupportBound;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return upperSupportBound;
        }
        else {
            return lowerSupportBound;
        }
    }
    else {
        if (lowerTail) {
            return (p * (upperSupportBound - lowerSupportBound)) + lowerSupportBound;
        }
        else {
            return upperSupportBound - (p * (upperSupportBound - lowerSupportBound));
        }
    }
}
exports.quantileSync = quantileSync;
function quantile(p, lowerSupportBound, upperSupportBound, lowerTail = true) {
    return Promise.resolve(quantileSync(p, lowerSupportBound, upperSupportBound, lowerTail));
}
exports.quantile = quantile;
function randomSync(n, lowerSupportBound, upperSupportBound, seed, randoms) {
    return random_1.randSync(n, quantileSync, [lowerSupportBound, upperSupportBound], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, lowerSupportBound, upperSupportBound, seed, randoms) {
    return random_1.rand(n, quantileSync, [lowerSupportBound, upperSupportBound], seed, []);
}
exports.random = random;
