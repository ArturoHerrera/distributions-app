export declare function lnBeta(x: any, y: any): number;
/**
 * a function to calculate the "d_i" values from
 *      http://www.stat.tamu.edu/~jnewton/604/chap3.pdf  pp.15-16
 * in the calculation of the IB(incomplete beta function)
 *
 * @param i - the index of the d_i values
 * @param x - parameter from the IB function
 * @param a - parameter from the IB function
 * @param b - parameter from the IB function
 * @returns {any} - the d_i value
 */
export declare function d(i: number, x: number, a: number, b: number): number;
export declare function continuedFraction(x: number, a: number, b: number): number;
export declare function lnIncompleteBeta(x: number, a: number, b: number): number;
export declare function incompleteBeta(x: any, a: any, b: any): number;
export declare function inverseIncompleteBeta(p: any, a: any, b: any): any;
export declare function pdfSync(x: any, alpha: any, beta: any): number;
export declare function pdf(x: any, alpha: any, beta: any): Promise<{}>;
export declare function cdfSync(x: any, alpha: any, beta: any, lowerTail?: boolean): number;
export declare function cdf(x: any, alpha: any, beta: any, lowerTail?: boolean): Promise<{}>;
export declare function quantileSync(p: any, alpha: any, beta: any, lowerTail?: boolean): any;
export declare function quantile(x: any, alpha: any, beta: any, lowerTail?: boolean): Promise<{}>;
export declare function randomSync(n: any, alpha: any, beta: any, seed?: number | string, randoms?: any): any[];
export declare function random(n: any, alpha: any, beta: any, seed?: number | string): Promise<{}>;
