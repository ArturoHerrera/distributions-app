(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.distriprob = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
"use strict";
function asyncGen(functionDependencies, script, scriptArgs) {
    let worker;
    if (isNode()) {
        const scriptString = createScriptStr(functionDependencies, script, scriptArgs, true);
        const Worker = require("webworker-threads").Worker;
        const functionArg = new Function(scriptString);
        worker = new Worker(functionArg);
    }
    else {
        const scriptString = createScriptStr(functionDependencies, script, scriptArgs, false);
        const blobURL = URL.createObjectURL(new Blob([scriptString], { type: "application/javascript" }));
        worker = new Worker(blobURL);
        URL.revokeObjectURL(blobURL);
    }
    return new Promise((resolve, reject) => {
        worker.onmessage = function (event) {
            worker.terminate();
            resolve(event.data);
        };
        worker.postMessage("get to work!");
    });
}
exports.asyncGen = asyncGen;
function createScriptStr(functionDependencies, script, scriptArgs, node) {
    let argString = "";
    for (let i = 0; i < scriptArgs.length; i++) {
        let arg = scriptArgs[i];
        if (Array.isArray(arg)) {
            argString += "[" + arg.toString() + "]";
        }
        else if (arg === null) {
            argString += "null";
        }
        else if (typeof arg === "string") {
            argString += `"${arg}"`;
        }
        else {
            argString += arg.toString();
        }
        if (i < (scriptArgs.length - 1)) {
            argString += ", ";
        }
    }
    let result = "";
    for (let funct of functionDependencies) {
        result += funct.toString() + "\n";
    }
    result += "let result = (" + script.toString() + ")(" + argString + ");\n";
    if (node) {
        result += "self.onmessage = function(event) {\n";
    }
    else {
        result += "self.onmessage = function(event) {\n";
    }
    result += "postMessage(result);\n";
    result += "};\n";
    return result;
}
function isNode() {
    return typeof process === "object" && process + "" === "[object process]";
}

}).call(this,require('_process'))
},{"_process":21,"webworker-threads":30}],2:[function(require,module,exports){
"use strict";
const async_1 = require("./async");
const random_1 = require("./random");
const cfs = require("./continuedFractionSolver");
const gamma = require("./gamma");
const rf = require("./rootFind");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lnGamma = gamma.lnGamma;
const continuedFractionSolver = cfs.continuedFractionSolver;
const rootFind = rf.rootFind;
function lnBeta(x, y) {
    return (lnGamma(x) + lnGamma(y)) - lnGamma(x + y);
}
exports.lnBeta = lnBeta;
/**
 * a function to calculate the "d_i" values from
 *      http://www.stat.tamu.edu/~jnewton/604/chap3.pdf  pp.15-16
 * in the calculation of the IB(incomplete beta function)
 *
 * @param i - the index of the d_i values
 * @param x - parameter from the IB function
 * @param a - parameter from the IB function
 * @param b - parameter from the IB function
 * @returns {any} - the d_i value
 */
function d(i, x, a, b) {
    var result;
    var m;
    if (i % 2 === 0) {
        m = i / 2;
        result = (m * (b - m) * x) / ((a + 2 * m - 1) * (a + 2 * m));
    }
    else if (i % 2 === 1) {
        m = (i - 1) / 2;
        result = -((a + m) * (a + b + m) * x) / ((a + 2 * m) * (a + 2 * m + 1));
    }
    return result;
}
exports.d = d;
function continuedFraction(x, a, b) {
    function num(j) {
        if (j === 1) {
            return 1;
        }
        else {
            return d(j - 1, x, a, b);
        }
    }
    function denom(j) {
        if (j === 0) {
            return 0;
        }
        else {
            return 1;
        }
    }
    return continuedFractionSolver(num, denom);
}
exports.continuedFraction = continuedFraction;
function lnIncompleteBeta(x, a, b) {
    const comparator = (a + 1) / (a + b + 1);
    if (x >= comparator) {
        return Math.log(1 - Math.exp(lnIncompleteBeta(1 - x, b, a)));
    }
    const alnx = a * Math.log(x);
    const bln1MinusX = b * Math.log(1 - x);
    const lna = Math.log(a);
    const lnBetaAB = lnBeta(a, b);
    const lnContinuedFraction = Math.log(continuedFraction(x, a, b));
    return alnx + bln1MinusX - lna - lnBetaAB + lnContinuedFraction;
}
exports.lnIncompleteBeta = lnIncompleteBeta;
function incompleteBeta(x, a, b) {
    return Math.exp(lnIncompleteBeta(x, a, b));
}
exports.incompleteBeta = incompleteBeta;
function inverseIncompleteBeta(p, a, b) {
    const lnIncompBeta = function (x) {
        return lnIncompleteBeta(x, a, b);
    };
    const derivativeLnIncompleteBeta = function (x) {
        const lnBetaAB = lnBeta(a, b);
        const lnIncBetaXAB = lnIncompleteBeta(x, a, b);
        const bMinus1TimesLn1MinusX = (b - 1) * Math.log(1 - x);
        const aMinus1TimesLnX = (a - 1) * Math.log(x);
        return Math.exp(bMinus1TimesLn1MinusX + aMinus1TimesLnX - lnBetaAB - lnIncBetaXAB);
    };
    return rootFind(lnIncompBeta, derivativeLnIncompleteBeta, Math.log(p), 0.5, 1, 0);
}
exports.inverseIncompleteBeta = inverseIncompleteBeta;
function pdfSync(x, alpha, beta) {
    if (x < 0 || x > 1) {
        return 0;
    }
    else {
        return Math.exp(((alpha - 1) * Math.log(x)) + ((beta - 1) * Math.log(1 - x))
            - lnBeta(alpha, beta));
    }
}
exports.pdfSync = pdfSync;
function pdf(x, alpha, beta) {
    return async_1.asyncGen([lnGamma, lnBeta], pdfSync, [x, alpha, beta]);
}
exports.pdf = pdf;
function cdfSync(x, alpha, beta, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if (x >= 1) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        if (lowerTail) {
            return incompleteBeta(x, alpha, beta);
        }
        else {
            return incompleteBeta(1 - x, beta, alpha);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, alpha, beta, lowerTail = true) {
    return async_1.asyncGen([
        lnBeta,
        lnGamma,
        continuedFractionSolver,
        d,
        continuedFraction,
        lnIncompleteBeta,
        incompleteBeta
    ], cdfSync, [x, alpha, beta, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, alpha, beta, lowerTail = true) {
    function f(val) {
        return cdfSync(val, alpha, beta, lowerTail);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, alpha, beta);
        }
        else {
            return -pdfSync(val, alpha, beta);
        }
    }
    const mean = alpha / (alpha + beta);
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, mean, 1, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(x, alpha, beta, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        lnBeta,
        lnGamma,
        continuedFractionSolver,
        d,
        continuedFraction,
        lnIncompleteBeta,
        incompleteBeta,
        pdfSync,
        cdfSync
    ], quantileSync, [x, alpha, beta, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, alpha, beta, seed, randoms) {
    return random_1.randSync(n, quantileSync, [alpha, beta], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, alpha, beta, seed) {
    return random_1.rand(n, quantileSync, [alpha, beta], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        lnBeta,
        lnGamma,
        continuedFractionSolver,
        d,
        continuedFraction,
        lnIncompleteBeta,
        incompleteBeta,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],3:[function(require,module,exports){
"use strict";
const gamma = require("./gamma");
const beta = require("./beta");
const rf = require("./rootFind");
const cfs = require("./continuedFractionSolver");
const pf = require("./primeFactors");
const async_1 = require("./async");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lnGamma = gamma.lnGamma;
const lnFactorial = gamma.lnFactorial;
const incompleteBeta = beta.incompleteBeta;
const discreteQuantileFind = rf.discreteQuantileFind;
const continuedFractionSolver = cfs.continuedFractionSolver;
const lnFactorialFractionEval = pf.lnFactorialFractionEval;
function lnBinomialCoefficient(n, chooseK) {
    if (typeof n !== "number" || typeof chooseK !== "number") {
        throw new Error(`The binomial coefficient function is only defined for numeric${""} arguments n and k.`);
    }
    if (n < chooseK) {
        throw new Error(`The binomial coefficient function is only defined for n greater${""} than or equal to k.`);
    }
    if (!Number.isInteger(n) || !Number.isInteger(chooseK)) {
        throw new Error(`The binomial coefficient function is defined for integer${""} arguments n and k.`);
    }
    if (chooseK === 0 || chooseK === n) {
        return 0;
    }
    return lnFactorialFractionEval([n], [chooseK, n - chooseK]);
}
exports.lnBinomialCoefficient = lnBinomialCoefficient;
function pmfSync(k, trials, probSuccess) {
    const p = probSuccess;
    if (!Number.isInteger(k) || k < 0 || k > trials) {
        return 0;
    }
    else {
        return Math.exp(lnBinomialCoefficient(trials, k) + (k * Math.log(p)) +
            ((trials - k) * Math.log(1 - p)));
    }
}
exports.pmfSync = pmfSync;
function pmf(k, trials, probSuccess) {
    return async_1.asyncGen([
        pf.primesLessThanOrEqualTo,
        pf._factorialPrimes,
        pf.factorialPrimes,
        lnFactorialFractionEval,
        lnBinomialCoefficient
    ], pmfSync, [k, trials, probSuccess]);
}
exports.pmf = pmf;
function cdfSync(k, trials, probSuccess, lowerTail = true) {
    if (k < 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if (k > trials) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        k = Math.floor(k);
        if (lowerTail) {
            return incompleteBeta(1 - probSuccess, trials - k, k + 1);
        }
        else {
            return incompleteBeta(probSuccess, k + 1, trials - k);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(k, trials, probSuccess, lowerTail = true) {
    return async_1.asyncGen([
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta
    ], cdfSync, [k, trials, probSuccess, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, trials, probSuccess, lowerTail = true) {
    function simplifiedCDF(val) {
        return cdfSync(val, trials, probSuccess, lowerTail);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return trials;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return trials;
        }
        else {
            return 0;
        }
    }
    else {
        const mean = Math.floor(trials * p);
        return discreteQuantileFind(simplifiedCDF, p, trials, 0, mean, lowerTail);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, trials, probSuccess, lowerTail = true) {
    return async_1.asyncGen([
        discreteQuantileFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        cdfSync
    ], quantileSync, [p, trials, probSuccess, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, trials, probSuccess, seed, randoms) {
    return random_1.randSync(n, quantileSync, [trials, probSuccess], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, trials, probSuccess, seed) {
    return random_1.rand(n, quantileSync, [trials, probSuccess], seed, [
        discreteQuantileFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./beta":2,"./continuedFractionSolver":5,"./gamma":8,"./primeFactors":12,"./random":13,"./rootFind":14}],4:[function(require,module,exports){
"use strict";
const continuedFractionSolver_1 = require("./continuedFractionSolver");
const gamma = require("./gamma");
const rf = require("./rootFind");
const async_1 = require("./async");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lowerIncompleteGamma = gamma.lowerIncompleteGamma;
const upperIncompleteGamma = gamma.upperIncompleteGamma;
const lnGamma = gamma.lnGamma;
const rootFind = rf.rootFind;
function pdfSync(x, degreesOfFreedom) {
    if (x <= 0) {
        return 0;
    }
    else {
        let k = degreesOfFreedom;
        let lnNumerator = ((k / 2) - 1) * Math.log(x) - (x / 2);
        let lnDenominator = ((k / 2) * Math.log(2)) + lnGamma(k / 2);
        return Math.exp(lnNumerator - lnDenominator);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, degreesOfFreedom) {
    return async_1.asyncGen([lnGamma, pdfSync], pdfSync, [x, degreesOfFreedom]);
}
exports.pdf = pdf;
function cdfSync(x, degreesOfFreedom, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            return lowerIncompleteGamma(x / 2, degreesOfFreedom / 2);
        }
        else {
            return upperIncompleteGamma(x / 2, degreesOfFreedom / 2);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma
    ], cdfSync, [x, degreesOfFreedom, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, degreesOfFreedom, lowerTail = true) {
    function f(val) {
        return cdfSync(val, degreesOfFreedom);
    }
    function fPrime(val) {
        return pdfSync(val, degreesOfFreedom);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, 1, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        pdfSync,
        cdfSync
    ], quantileSync, [p, degreesOfFreedom, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, degreesOfFreedom, seed, randoms) {
    return random_1.randSync(n, quantileSync, [degreesOfFreedom], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, degreesOfFreedom, seed) {
    return random_1.rand(n, quantileSync, [degreesOfFreedom], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],5:[function(require,module,exports){
"use strict";
/**
 * This function uses the modified Lentz's method for solving continued fractions of the
 * form :
 *               a1   a2   a3   a4   a5
 *          b0 + ---  ---  ---  ---  --- . . .
 *               b1+  b2+  b3+  b4+  b5+
 *
 * for a description of the algorithm, visit the web page:
 *      http://www.aip.de/groups/soe/local/numres/bookcpdf/c5-2.pdf
 *
 *
 * @param a - a function that has one argument, j, that gives the a values in the
 *          continued fraction representation above for j = 1, 2, 3, ....
 * @param b - a function that has one argument, j, that gives the b values in the
 *          continued fraction representation above for j = 1, 2, 3, ....
 * @returns {*} - the estimated value of the continued fraction
 */
function continuedFractionSolver(a, b) {
    const EPS = 1e-15;
    const TINY = 1e-45;
    let fJ;
    let fJMinus1;
    let cJ;
    let cJMinus1;
    let dJ;
    let dJMinus1 = 0;
    let deltaJ;
    let j = 1;
    if (b(0) === 0) {
        fJMinus1 = TINY;
    }
    else {
        fJMinus1 = b(0);
    }
    cJMinus1 = fJMinus1;
    do {
        dJ = b(j) + (a(j) * dJMinus1);
        if (dJ === 0) {
            dJ = TINY;
        }
        cJ = b(j) + (a(j) / cJMinus1);
        if (cJ === 0) {
            cJ = TINY;
        }
        dJ = 1 / dJ;
        deltaJ = cJ * dJ;
        fJ = fJMinus1 * deltaJ;
        fJMinus1 = fJ;
        cJMinus1 = cJ;
        dJMinus1 = dJ;
        j++;
    } while (Math.abs(deltaJ - 1) >= EPS);
    return fJ;
}
exports.continuedFractionSolver = continuedFractionSolver;

},{}],6:[function(require,module,exports){
"use strict";
const async_1 = require("./async");
const random_1 = require("./random");
const gamma = require("./gamma");
const cf = require("./continuedFractionSolver");
const rf = require("./rootFind");
const gammaCDF = gamma.gammaCDF;
const rootFind = rf.rootFind;
function pdfSync(x, lambda) {
    if (x < 0) {
        return 0;
    }
    else {
        return lambda * Math.exp((-lambda) * x);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, lambda) {
    return async_1.asyncGen([], pdfSync, [x, lambda]);
}
exports.pdf = pdf;
function cdfSync(x, lambda, lowerTail = true) {
    if (x < 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            const possibleResult = 1 - Math.exp((-lambda) * x);
            if (possibleResult >= 0.1) {
                return possibleResult;
            }
            else {
                return gammaCDF(x, 1, 1 / lambda, true);
            }
        }
        else {
            return Math.exp((-lambda) * x);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, lambda, lowerTail = true) {
    return async_1.asyncGen([
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma
    ], cdfSync, [x, lambda, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, lambda, lowerTail = true) {
    function f(val) {
        return cdfSync(val, lambda, lowerTail);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, lambda);
        }
        else {
            return -pdfSync(val, lambda);
        }
    }
    const mean = 1 / lambda;
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, mean, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, lambda, lowerTail = true) {
    return async_1.asyncGen([
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        cdfSync
    ], quantileSync, [p, lambda, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, lambda, seed, randoms) {
    return random_1.randSync(n, quantileSync, [lambda], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, lambda, seed) {
    return random_1.rand(n, quantileSync, [lambda], seed, [
        gammaCDF,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        cf.continuedFractionSolver,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],7:[function(require,module,exports){
"use strict";
const gamma = require("./gamma");
const beta = require("./beta");
const rf = require("./rootFind");
const async_1 = require("./async");
const random_1 = require("./random");
const continuedFractionSolver_1 = require("./continuedFractionSolver");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lnGamma = gamma.lnGamma;
const lnBeta = beta.lnBeta;
const incompleteBeta = beta.incompleteBeta;
const rootFind = rf.rootFind;
function pdfSync(x, dof1, dof2) {
    if (x <= 0) {
        return 0;
    }
    else {
        const lnNumNum = (dof1 * Math.log(dof1 * x)) + (dof2 * Math.log(dof2));
        const lnNumDenom = (dof1 + dof2) * Math.log((dof1 * x) + dof2);
        const lnNum = 0.5 * (lnNumNum - lnNumDenom);
        const lnDenom = Math.log(x) + lnBeta(dof1 / 2, dof2 / 2);
        return Math.exp(lnNum - lnDenom);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, dof1, dof2) {
    return async_1.asyncGen([beta.lnBeta, gamma.lnGamma,], pdfSync, [x, dof1, dof2]);
}
exports.pdf = pdf;
function cdfSync(x, dof1, dof2, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        if (lowerTail) {
            return incompleteBeta((dof1 * x) / (dof2 + (dof1 * x)), dof1 / 2, dof2 / 2);
        }
        else {
            return incompleteBeta(dof2 / (dof2 + (dof1 * x)), dof2 / 2, dof1 / 2);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, dof1, dof2, lowerTail = true) {
    return async_1.asyncGen([
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta
    ], cdfSync, [x, dof1, dof2, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, dof1, dof2, lowerTail = true) {
    function f(val) {
        return cdfSync(val, dof1, dof2);
    }
    function fPrime(val) {
        return pdfSync(val, dof1, dof2);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        return rootFind(f, fPrime, p, 1, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, dof1, dof2, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ], quantileSync, [p, dof1, dof2, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, dof1, dof2, seed, randoms) {
    return random_1.randSync(n, quantileSync, [dof1, dof2], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, dof1, dof2, seed) {
    return random_1.rand(n, quantileSync, [dof1, dof2], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./beta":2,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],8:[function(require,module,exports){
"use strict";
const async_1 = require("./async");
const random_1 = require("./random");
const cfs = require("./continuedFractionSolver");
const rf = require("./rootFind");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const continuedFractionSolver = cfs.continuedFractionSolver;
const rootFind = rf.rootFind;
function lnGamma(val) {
    const EULER_MASCHERONI = 0.57721566490153286060651209008240243104215933593992;
    let result;
    var valFloor = Math.floor(val);
    var x = val - valFloor;
    if (x === 0) {
        result = 0;
        for (var i = 2; i < valFloor; i++) {
            result = result + Math.log(i);
        }
    }
    else {
        var sum = ((1 / 2) - x) * (EULER_MASCHERONI + Math.log(2));
        sum = sum + ((1 - x) * Math.log(Math.PI));
        sum = sum - ((1 / 2) * Math.log(Math.sin(Math.PI * x)));
        var infiniteSum = 0;
        for (var n = 1; n <= 100; n++) {
            var addition = (Math.sin(2 * Math.PI * n * x) * Math.log(n)) / n;
            infiniteSum = infiniteSum + addition;
        }
        sum = sum + ((1 / Math.PI) * infiniteSum);
        result = sum;
        for (var j = 0; j < valFloor; j++) {
            result = result + Math.log(x);
            x++;
        }
    }
    return result;
}
exports.lnGamma = lnGamma;
/**
 * This function gives the log of the extended(on all non-negative n, possibly
 * non-integer n) factorial function.
 * @param n
 */
function lnFactorial(n) {
    if (typeof n !== "number") {
        throw new Error(`The log factorial function is only defined for numeric arguments.`);
    }
    if (n < 0) {
        throw new Error(`The log factorial of negative numbers in not defined.`);
    }
    if (n === 0) {
        return Number.NEGATIVE_INFINITY;
    }
    return lnGamma(n + 1);
}
exports.lnFactorial = lnFactorial;
function gammaContinuedFraction(x, a) {
    function num(j) {
        if (j === 1) {
            return 1;
        }
        else if (j % 2 === 0) {
            return j / 2 - a;
        }
        else if (j % 2 === 1) {
            return Math.floor(j / 2);
        }
        else {
            throw new Error(`argument must be non-negative integer`);
        }
    }
    function denom(j) {
        if (j === 0) {
            return 0;
        }
        else if (j % 2 === 0) {
            return 1;
        }
        else if (j % 2 === 1) {
            return x;
        }
        else {
            throw new Error(`argument must be non-negative integer`);
        }
    }
    return continuedFractionSolver(num, denom);
}
exports.gammaContinuedFraction = gammaContinuedFraction;
function lnLowerIncompleteGammaA(x, a) {
    const numerator = (a * Math.log(x)) - x;
    const denominator = lnGamma(a + 1);
    let summands = [1];
    let infiniteSum = 0;
    let summandDenominator;
    let i = 1;
    do {
        summandDenominator = 0;
        for (var j = 1; j <= i; j++) {
            summandDenominator = summandDenominator + Math.log(a + j);
        }
        summands.push(Math.exp((i * Math.log(x)) - summandDenominator));
        i++;
    } while (summands[i - 1] > 0);
    summands = summands.sort();
    for (var k = 0; k < summands.length; k++) {
        infiniteSum += summands[k];
    }
    return numerator - denominator + Math.log(infiniteSum);
}
exports.lnLowerIncompleteGammaA = lnLowerIncompleteGammaA;
function lnUpperIncompleteGammaB(x, a) {
    const numerator = (a * Math.log(x)) - x;
    const denominator = lnGamma(a);
    const lnContinuedFraction = Math.log(gammaContinuedFraction(x, a));
    return numerator - denominator + lnContinuedFraction;
}
exports.lnUpperIncompleteGammaB = lnUpperIncompleteGammaB;
function lnLowerIncompleteGamma(x, a) {
    if (x <= a) {
        return lnLowerIncompleteGammaA(x, a);
    }
    else if (x > a && x <= a + 1) {
        const weight = x - a;
        const incompleteGammaA = lnLowerIncompleteGammaA(x, a);
        const incompleteGammaB = Math.log(1 - Math.exp(lnUpperIncompleteGammaB(x, a)));
        return ((1 - weight) * incompleteGammaA) + (weight * incompleteGammaB);
    }
    else {
        return Math.log(1 - Math.exp(lnUpperIncompleteGammaB(x, a)));
    }
}
exports.lnLowerIncompleteGamma = lnLowerIncompleteGamma;
function lnUpperIncompleteGamma(x, a) {
    if (x <= a) {
        return Math.log(1 - Math.exp(lnLowerIncompleteGammaA(x, a)));
    }
    else if (x > a && x <= a + 1) {
        const weight = x - a;
        const incompleteGammaA = Math.log(1 - Math.exp(lnLowerIncompleteGammaA(x, a)));
        const incompleteGammaB = lnUpperIncompleteGammaB(x, a);
        return ((1 - weight) * incompleteGammaA) + (weight * incompleteGammaB);
    }
    else {
        return lnUpperIncompleteGammaB(x, a);
    }
}
exports.lnUpperIncompleteGamma = lnUpperIncompleteGamma;
function lowerIncompleteGamma(x, a) {
    if (x <= a) {
        return Math.exp(lnLowerIncompleteGammaA(x, a));
    }
    else if (x > a && x <= a + 1) {
        var weight = x - a;
        var incompleteGammaA = Math.exp(lnLowerIncompleteGammaA(x, a));
        var incompleteGammaB = 1 - Math.exp(lnUpperIncompleteGammaB(x, a));
        return (1 - weight) * incompleteGammaA + weight * incompleteGammaB;
    }
    else {
        return 1 - Math.exp(lnUpperIncompleteGammaB(x, a));
    }
}
exports.lowerIncompleteGamma = lowerIncompleteGamma;
function upperIncompleteGamma(x, a) {
    if (x <= a) {
        return 1 - Math.exp(lnLowerIncompleteGammaA(x, a));
    }
    else if (x > a && x <= a + 1) {
        var weight = x - a;
        var incompleteGammaA = 1 - Math.exp(lnLowerIncompleteGammaA(x, a));
        var incompleteGammaB = Math.exp(lnUpperIncompleteGammaB(x, a));
        return (1 - weight) * incompleteGammaA + weight * incompleteGammaB;
    }
    else {
        return Math.exp(lnUpperIncompleteGammaB(x, a));
    }
}
exports.upperIncompleteGamma = upperIncompleteGamma;
function inverseLowerIncompleteGamma(p, a, initialEstimate) {
    if (!initialEstimate) {
        initialEstimate = a;
    }
    const lnLowIncompGamma = function (x) {
        return lnLowerIncompleteGamma(x, a);
    };
    const derivativeLnLowIncompGammma = function (x) {
        return Math.exp(((a - 1) * Math.log(x)) - x - lnGamma(a) + lnLowerIncompleteGamma(x, a));
    };
    return rootFind(lnLowIncompGamma, derivativeLnLowIncompGammma, Math.log(p), initialEstimate, null, 0);
}
exports.inverseLowerIncompleteGamma = inverseLowerIncompleteGamma;
function pdfSync(x, shape, scale) {
    if (x <= 0) {
        return 0;
    }
    else {
        const lnNum = ((shape - 1) * Math.log(x)) - (x / scale);
        const lnDenom = (lnGamma(shape) + (shape * Math.log(scale)));
        return Math.exp(lnNum - lnDenom);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, shape, scale) {
    return async_1.asyncGen([lnGamma], pdfSync, [x, shape, scale]);
}
exports.pdf = pdf;
function cdfSync(x, shape, scale, lowerTail = true) {
    return gammaCDF(x, shape, scale, lowerTail);
}
exports.cdfSync = cdfSync;
function gammaCDF(x, shape, scale, lowerTail = true) {
    if (x <= 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        let a = x / scale;
        if (lowerTail) {
            return lowerIncompleteGamma(a, shape);
        }
        else {
            return upperIncompleteGamma(a, shape);
        }
    }
}
exports.gammaCDF = gammaCDF;
function cdf(x, shape, scale, lowerTail = true) {
    return async_1.asyncGen([
        lnGamma,
        gammaContinuedFraction,
        continuedFractionSolver,
        lnLowerIncompleteGammaA,
        lnUpperIncompleteGammaB,
        lowerIncompleteGamma,
        upperIncompleteGamma
    ], cdfSync, [x, shape, scale, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, shape, scale, lowerTail = true) {
    function f(val) {
        return cdfSync(val, shape, scale, lowerTail);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, shape, scale);
        }
        else {
            return -pdfSync(val, shape, scale);
        }
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        const distMean = shape * scale;
        return rootFind(f, fPrime, p, distMean, null, 0);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, shape, scale, lowerTail = true) {
    return async_1.asyncGen([
        lnGamma,
        gammaContinuedFraction,
        continuedFractionSolver,
        lnLowerIncompleteGammaA,
        lnUpperIncompleteGammaB,
        lowerIncompleteGamma,
        upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        gammaCDF,
        cdfSync
    ], quantileSync, [p, shape, scale, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, shape, scale, seed, randoms) {
    return random_1.randSync(n, quantileSync, [shape, scale], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, shape, scale, seed) {
    return random_1.rand(n, quantileSync, [shape, scale], seed, [
        lnGamma,
        gammaContinuedFraction,
        continuedFractionSolver,
        lnLowerIncompleteGammaA,
        lnUpperIncompleteGammaB,
        lowerIncompleteGamma,
        upperIncompleteGamma,
        rootFind,
        rf.newton,
        rf.bisection,
        pdfSync,
        gammaCDF,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./random":13,"./rootFind":14}],9:[function(require,module,exports){
"use strict";
const async_1 = require("./async");
const rf = require("./rootFind");
const pf = require("./primeFactors");
const random_1 = require("./random");
const discreteQuantileFind = rf.discreteQuantileFind;
const lnFactorialFractionEval = pf.lnFactorialFractionEval;
const primesLessThanOrEqualTo = pf.primesLessThanOrEqualTo;
const _factorialPrimes = pf._factorialPrimes;
const factorialPrimes = pf.factorialPrimes;
function pmfSync(sampleSuccesses, draws, successPop, totalPop) {
    const k = sampleSuccesses;
    const n = draws;
    const K = successPop;
    const N = totalPop;
    if (N === 0 || K === 0 || n === 0) {
        if (k === 0) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if (N === K) {
        if (k === n) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if (N === n) {
        if (k === K) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if (k < 0 || k < (n + K - N) || k > K || k > n) {
        return 0;
    }
    else if (K === k) {
        if (n === k) {
            return Math.exp(lnFactorialFractionEval([N - K, n], [N]));
        }
        else {
            return Math.exp(lnFactorialFractionEval([N - K, n], [n - k, N]));
        }
    }
    else if (k === 0) {
        if (N - K - n === 0) {
            return Math.exp(lnFactorialFractionEval([N - K, N - n], [N]));
        }
        else {
            return Math.exp(lnFactorialFractionEval([N - K, N - n], [N - K - n, N]));
        }
    }
    else if ((N - K) === (n - k)) {
        return Math.exp(lnFactorialFractionEval([K, N - n, n], [K - k, k, N]));
    }
    else if (n === k) {
        return Math.exp(lnFactorialFractionEval([K, N - n], [K - n, N]));
    }
    else {
        return Math.exp(lnFactorialFractionEval([K, n, N - K, N - n], [N, k, K - k, n - k, N - K - n + k]));
    }
}
exports.pmfSync = pmfSync;
function pmf(sampleSuccesses, draws, successPop, totalPop) {
    return async_1.asyncGen([
        primesLessThanOrEqualTo,
        _factorialPrimes,
        factorialPrimes,
        lnFactorialFractionEval
    ], pmfSync, [sampleSuccesses, draws, successPop, totalPop]);
}
exports.pmf = pmf;
function cdfSync(sampleSuccesses, draws, successPop, totalPop, lowerTail = true) {
    const k = sampleSuccesses;
    const n = draws;
    const K = successPop;
    const N = totalPop;
    let mean = n * (K / N);
    let easyCaseResult = _cdfSyncEasyCases(k, n, K, N, lowerTail);
    if (easyCaseResult !== null) {
        return easyCaseResult;
    }
    else {
        if (k <= mean) {
            const lnh0Eval = lnh0(n, K, N);
            return _cdfSyncHardCase(lnh0Eval, k, draws, successPop, totalPop, lowerTail);
        }
        else {
            const lnhMaxEval = lnhMax(n, K, N);
            return _cdfSyncHardCase(lnhMaxEval, k, draws, successPop, totalPop, lowerTail);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(sampleSuccesses, draws, successPop, totalPop, lowerTail = true) {
    return async_1.asyncGen([
        primesLessThanOrEqualTo,
        _factorialPrimes,
        factorialPrimes,
        lnFactorialFractionEval,
        _cdfSyncEasyCases,
        _cdfSyncHardCase,
        lnh0,
        lnhMax
    ], cdfSync, [sampleSuccesses, draws, successPop, totalPop, lowerTail]);
}
exports.cdf = cdf;
function _cdfSyncEasyCases(k, n, K, N, lowerTail) {
    if (N === 0 || K === 0 || n === 0) {
        if (k >= 0) {
            if (lowerTail) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else {
            if (lowerTail) {
                return 0;
            }
            else {
                return 1;
            }
        }
    }
    else if (N === K) {
        if (k >= n) {
            if (lowerTail) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else {
            if (lowerTail) {
                return 0;
            }
            else {
                return 1;
            }
        }
    }
    else if (N === n) {
        if (k >= K) {
            if (lowerTail) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else {
            if (lowerTail) {
                return 0;
            }
            else {
                return 1;
            }
        }
    }
    else if (k >= K || k >= n) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else if (k < 0 || k < (n + K - N)) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        return null;
    }
}
function _cdfSyncHardCase(lnhEval, k, n, K, N, lowerTail) {
    let sum = 0;
    let current = lnhEval;
    let mean = n * (K / N);
    if (k <= mean) {
        for (let i = 0; i <= k; i++) {
            sum += Math.exp(current);
            current = Math.log(((K - i) * (n - i)) / ((i + 1) * (N - K - n + i + 1))) + current;
        }
        if (lowerTail) {
            return sum;
        }
        else {
            return 1 - sum;
        }
    }
    else {
        for (let i = Math.min(n, K); i > k; i--) {
            sum += Math.exp(current);
            current = Math.log((i * (N - K - n + i)) / ((K - i + 1) * (n - i + 1))) + current;
        }
        if (lowerTail) {
            return 1 - sum;
        }
        else {
            return sum;
        }
    }
}
function quantileSync(p, draws, successPop, totalPop, lowerTail = true, lnh0Eval, lnhMaxEval) {
    let h0log = lnh0Eval;
    let hMaxlog = lnhMaxEval;
    let mean = draws * (successPop / totalPop);
    function simplifiedCDF(val) {
        let easyCaseResult = _cdfSyncEasyCases(val, draws, successPop, totalPop, lowerTail);
        if (easyCaseResult !== null) {
            return easyCaseResult;
        }
        else {
            if (val <= mean) {
                h0log = !h0log ? lnh0(draws, successPop, totalPop) : h0log;
                return _cdfSyncHardCase(h0log, val, draws, successPop, totalPop, lowerTail);
            }
            else {
                hMaxlog = !hMaxlog ? lnhMax(draws, successPop, totalPop) : hMaxlog;
                return _cdfSyncHardCase(hMaxlog, val, draws, successPop, totalPop, lowerTail);
            }
        }
    }
    const max = Math.min(successPop, draws);
    const min = Math.max(0, draws + successPop - totalPop);
    if (p === 0) {
        if (lowerTail) {
            return min;
        }
        else {
            return max;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return max;
        }
        else {
            return min;
        }
    }
    else {
        return discreteQuantileFind(simplifiedCDF, p, max, min, Math.floor(mean), lowerTail);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, draws, successPop, totalPop, lowerTail = true) {
    return async_1.asyncGen([
        discreteQuantileFind,
        primesLessThanOrEqualTo,
        _factorialPrimes,
        factorialPrimes,
        lnFactorialFractionEval,
        _cdfSyncEasyCases,
        _cdfSyncHardCase,
        lnh0,
        lnhMax
    ], quantileSync, [p, draws, successPop, totalPop, lowerTail]);
}
exports.quantile = quantile;
function lnh0(draws, successPop, totalPop) {
    const n = draws;
    const K = successPop;
    const N = totalPop;
    return lnFactorialFractionEval([N - K, N - n], [N, N - K - n]);
}
function lnhMax(draws, successPop, totalPop) {
    const n = draws;
    const K = successPop;
    const N = totalPop;
    const max = Math.min(n, K);
    return lnFactorialFractionEval([K, N - max], [N, K - max]);
}
function randomSync(n, draws, successPop, totalPop, seed, randoms) {
    // these two below are the heavy calculations for the distribution, so just do them once
    // here
    const lnh0Eval = lnh0(draws, successPop, totalPop);
    const lnhMaxEval = lnhMax(draws, successPop, totalPop);
    return random_1.randSync(n, quantileSync, [
        draws,
        successPop,
        totalPop,
        true,
        lnh0Eval,
        lnhMaxEval
    ], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, draws, successPop, totalPop, seed) {
    return random_1.rand(n, quantileSync, [draws, successPop, totalPop], seed, [
        discreteQuantileFind,
        primesLessThanOrEqualTo,
        _factorialPrimes,
        factorialPrimes,
        lnFactorialFractionEval,
        _cdfSyncEasyCases,
        _cdfSyncHardCase,
        lnh0,
        lnhMax
    ]);
}
exports.random = random;

},{"./async":1,"./primeFactors":12,"./random":13,"./rootFind":14}],10:[function(require,module,exports){
"use strict";
const continuedFractionSolver_1 = require("./continuedFractionSolver");
const gamma = require("./gamma");
const rf = require("./rootFind");
const async_1 = require("./async");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lowerIncompleteGamma = gamma.lowerIncompleteGamma;
const upperIncompleteGamma = gamma.upperIncompleteGamma;
const rootFind = rf.rootFind;
function pdfSync(x, mu, sigma) {
    if (typeof mu === "undefined" || mu === null) {
        mu = 0;
    }
    if (typeof sigma === "undefined" || sigma === null) {
        sigma = 1;
    }
    const coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
    const exponentNumerator = Math.pow((x - mu), 2);
    const exponentDenominator = 2 * Math.pow(sigma, 2);
    const exponent = -(exponentNumerator / exponentDenominator);
    return coefficient * Math.pow(Math.E, exponent);
}
exports.pdfSync = pdfSync;
function pdf(x, mu, sigma) {
    function script(a, b, c) {
        return pdfSync(a, b, c);
    }
    return async_1.asyncGen([pdfSync], script, [x, mu, sigma]);
}
exports.pdf = pdf;
function cdfSync(x, mu, sigma, lowerTail = true) {
    if (typeof mu === "undefined" || mu === null) {
        mu = 0;
    }
    if (typeof sigma === "undefined" || sigma === null) {
        sigma = 1;
    }
    const z = (x - mu) / sigma;
    function nonNegativeCase(val) {
        return (1 / 2) * (1 + lowerIncompleteGamma((val * val) / 2, 1 / 2));
    }
    if ((z >= 0 && lowerTail) || (z < 0 && !lowerTail)) {
        return (1 / 2) + (lowerIncompleteGamma((x * x) / 2, 1 / 2) / 2);
    }
    else {
        return upperIncompleteGamma((x * x) / 2, 1 / 2) / 2;
    }
}
exports.cdfSync = cdfSync;
function cdf(x, mu, sigma, lowerTail = true) {
    return async_1.asyncGen([
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma
    ], cdfSync, [x, mu, sigma, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, mu, sigma, lowerTail = true) {
    if (typeof mu === "undefined" || mu === null) {
        mu = 0;
    }
    if (typeof sigma === "undefined" || sigma === null) {
        sigma = 1;
    }
    function f(val) {
        return cdfSync(val, 0, 1);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, 0, 1);
        }
        else {
            return -pdfSync(val, 0, 1);
        }
    }
    if (p === 0) {
        if (lowerTail) {
            return Number.NEGATIVE_INFINITY;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return Number.NEGATIVE_INFINITY;
        }
    }
    else {
        let z = rootFind(f, fPrime, p, 0, null, null);
        return (z * sigma) + mu;
    }
}
exports.quantileSync = quantileSync;
function quantile(p, mu, sigma, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        pdfSync,
        cdfSync
    ], quantileSync, [p, mu, sigma, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, mu, sigma, seed, randoms) {
    if (typeof mu === "undefined" || mu === null) {
        mu = 0;
    }
    if (typeof sigma === "undefined" || sigma === null) {
        sigma = 1;
    }
    return random_1.randSync(n, quantileSync, [mu, sigma, true], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, mu, sigma, seed) {
    return random_1.rand(n, quantileSync, [mu, sigma], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        continuedFractionSolver_1.continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],11:[function(require,module,exports){
"use strict";
const gamma = require("./gamma");
const rf = require("./rootFind");
const cfs = require("./continuedFractionSolver");
const async_1 = require("./async");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const continuedFractionSolver = cfs.continuedFractionSolver;
const lnGamma = gamma.lnGamma;
const lnFactorial = gamma.lnFactorial;
const lowerIncompleteGamma = gamma.lowerIncompleteGamma;
const upperIncompleteGamma = gamma.upperIncompleteGamma;
const lnUpperIncompleteGammaB = gamma.lnUpperIncompleteGammaB;
const discreteQuantileFind = rf.discreteQuantileFind;
function pmfSync(k, lambda) {
    if (k === 0) {
        return Math.exp((k * Math.log(lambda)) - lambda);
    }
    else {
        return Math.exp((k * Math.log(lambda)) - lambda - lnFactorial(k));
    }
}
exports.pmfSync = pmfSync;
function pmf(k, lambda) {
    return async_1.asyncGen([lnGamma, lnFactorial], pmfSync, [k, lambda]);
}
exports.pmf = pmf;
function cdfSync(k, lambda, lowerTail = true) {
    if (k < 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else {
        k = Math.floor(k);
        // TODO: check into slow computation of lowerIncompleteGamma for large lambda
        if (lowerTail) {
            return upperIncompleteGamma(lambda, k + 1);
        }
        else {
            return lowerIncompleteGamma(lambda, k + 1);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(k, lambda, lowerTail = true) {
    return async_1.asyncGen([
        continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lnUpperIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma
    ], cdfSync, [k, lambda, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, lambda, lowerTail = true) {
    function simplifiedCDF(val) {
        return cdfSync(val, lambda, lowerTail);
    }
    if (p === 0) {
        if (lowerTail) {
            return 0;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return 0;
        }
    }
    else {
        const mean = lambda;
        return discreteQuantileFind(simplifiedCDF, p, null, 0, mean, lowerTail);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, lambda, lowerTail = true) {
    return async_1.asyncGen([
        discreteQuantileFind,
        continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lnUpperIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        cdfSync
    ], quantileSync, [p, lambda, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, lambda, seed, randoms) {
    return random_1.randSync(n, quantileSync, [lambda], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, lambda, seed) {
    return random_1.rand(n, quantileSync, [lambda], seed, [
        discreteQuantileFind,
        continuedFractionSolver,
        gamma.lnGamma,
        gamma.gammaContinuedFraction,
        gamma.lnLowerIncompleteGammaA,
        gamma.lnUpperIncompleteGammaB,
        gamma.lnLowerIncompleteGamma,
        gamma.lnUpperIncompleteGamma,
        gamma.lowerIncompleteGamma,
        gamma.upperIncompleteGamma,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],12:[function(require,module,exports){
"use strict";
function primesLessThanOrEqualTo(n) {
    if (n === 1) {
        return [1];
    }
    else {
        const isPrime = [];
        const sqrtN = Math.sqrt(n);
        let index;
        let jIndex;
        for (let i = 2; i <= n; i++) {
            isPrime.push(true);
        }
        for (let i = 2; i < sqrtN; i++) {
            index = i - 2;
            if (isPrime[index]) {
                for (let j = i * i; j <= n; j += i) {
                    jIndex = j - 2;
                    isPrime[jIndex] = false;
                }
            }
        }
        let result = [];
        for (let i = 0; i < isPrime.length; i++) {
            if (isPrime[i]) {
                result.push(i + 2);
            }
        }
        return result;
    }
}
exports.primesLessThanOrEqualTo = primesLessThanOrEqualTo;
function _factorialPrimes(n) {
    if (n === 0 || n === 1) {
        return {};
    }
    else {
        const result = {};
        const primesLessThanOrEqualToN = primesLessThanOrEqualTo(n);
        let pToi;
        for (let p of primesLessThanOrEqualToN) {
            for (let i = 1; (pToi = Math.pow(p, i)) <= n; i++) {
                let bracketX = Math.floor(n / pToi);
                if (result[p]) {
                    result[p] += bracketX;
                }
                else {
                    result[p] = bracketX;
                }
            }
        }
        return result;
    }
}
exports._factorialPrimes = _factorialPrimes;
function factorialPrimes(nOrArrayOfNs) {
    const result = {};
    let current;
    const arrayOfNs = Array.isArray(nOrArrayOfNs) ? nOrArrayOfNs : [nOrArrayOfNs];
    for (let n of arrayOfNs) {
        current = _factorialPrimes(n);
        for (let p in current) {
            if (result[p]) {
                result[p] += current[p];
            }
            else {
                result[p] = current[p];
            }
        }
    }
    return result;
}
exports.factorialPrimes = factorialPrimes;
function lnFactorialFractionEval(numFactArgs, denomFactArgs) {
    const numPrimeFactorization = factorialPrimes(numFactArgs);
    const denomPrimeFactorization = factorialPrimes(denomFactArgs);
    // cancel out prime factors common to both numerator and denominator
    for (let p in numPrimeFactorization) {
        if (p in denomPrimeFactorization) {
            if (numPrimeFactorization[p] === denomPrimeFactorization[p]) {
                numPrimeFactorization[p] = 0;
                denomPrimeFactorization[p] = 0;
            }
            else if (numPrimeFactorization[p] >= denomPrimeFactorization[p]) {
                numPrimeFactorization[p] -= denomPrimeFactorization[p];
                denomPrimeFactorization[p] = 0;
            }
            else {
                denomPrimeFactorization[p] -= numPrimeFactorization[p];
                numPrimeFactorization[p] = 0;
            }
        }
    }
    let lnResult = 0;
    for (let p in numPrimeFactorization) {
        for (let i = 1; i <= numPrimeFactorization[p]; i++) {
            lnResult += Math.log(+p);
        }
    }
    for (let p in denomPrimeFactorization) {
        for (let i = 1; i <= denomPrimeFactorization[p]; i++) {
            lnResult -= Math.log(+p);
        }
    }
    return lnResult;
}
exports.lnFactorialFractionEval = lnFactorialFractionEval;

},{}],13:[function(require,module,exports){
"use strict";
const async_1 = require("./async");
function randSync(n, quantileFctn, quantileFctnArgs, seed, randoms) {
    if (!randoms) {
        randoms = [];
        const sr = require("seedrandom");
        let rng;
        if (seed) {
            rng = sr(seed);
        }
        else {
            rng = sr();
        }
        while (randoms.length < n) {
            let rand = rng();
            if (rand !== 0) {
                randoms.push(rng());
            }
        }
    }
    const result = [];
    while (randoms.length > 0) {
        const args = [randoms.pop()].concat(quantileFctnArgs);
        result.push(quantileFctn.apply(null, args));
    }
    return result;
}
exports.randSync = randSync;
function rand(n, quantileFctn, quantileFctnParams, seed, fctnDependencies) {
    const randoms = [];
    const sr = require("seedrandom");
    let rng;
    if (seed) {
        rng = sr(seed);
    }
    else {
        rng = sr();
    }
    while (randoms.length < n) {
        let rand = rng();
        if (rand !== 0) {
            randoms.push(rng());
        }
    }
    const dependencies = [quantileFctn].concat(fctnDependencies);
    const randSyncArgs = [n, quantileFctn, quantileFctnParams, null, randoms];
    return async_1.asyncGen(dependencies, randSync, randSyncArgs);
}
exports.rand = rand;

},{"./async":1,"seedrandom":22}],14:[function(require,module,exports){
"use strict";
function rootFind(fctn, derivativeFctn, value, initialRootEstimate, max, min) {
    var root = newton(fctn, derivativeFctn, value, initialRootEstimate, max, min);
    if (root === "non-convergent") {
        root = bisection(fctn, value, max, min);
    }
    return root;
}
exports.rootFind = rootFind;
function newton(fctn, derivativeFctn, value, initialRootEstimate, max, min) {
    const MAX_ITERATIONS = 1000;
    const RELATIVE_ERROR_TOLERANCE = 1e-17;
    let iterations = 0;
    let oldX = initialRootEstimate;
    let x;
    let approximateRelativeError;
    let fOfX;
    let fPrimeOfX;
    while (true) {
        fOfX = fctn(oldX);
        fPrimeOfX = derivativeFctn(oldX);
        x = oldX - ((fOfX - value) / fPrimeOfX);
        if (min !== null && x < min) {
            x = 1e-14 + min;
        }
        else if (max !== null && x > max) {
            x = max - 1e-14;
        }
        if (x === Infinity || x === -Infinity || fPrimeOfX === 0) {
            return "non-convergent";
        }
        approximateRelativeError = Math.abs(x - oldX) / Math.abs(value);
        if (approximateRelativeError < RELATIVE_ERROR_TOLERANCE
            || iterations > MAX_ITERATIONS) {
            break;
        }
        oldX = x;
        iterations++;
    }
    return x;
}
exports.newton = newton;
function bisection(fctn, value, max, min) {
    const MAX_ITERATIONS = 1000;
    const RELATIVE_ERROR_TOLERANCE = 0.00000000000001;
    let upper_root_bound;
    let upper_root_bound_function_value;
    let lower_root_bound;
    let lower_root_bound_function_value;
    let approximateRelativeError;
    let iterations = 0;
    let x;
    let oldX;
    let fOfOldX;
    if (max === null) {
        upper_root_bound = 1;
        do {
            upper_root_bound = 2 * Math.abs(upper_root_bound);
            upper_root_bound_function_value = fctn(upper_root_bound) - value;
        } while (upper_root_bound_function_value < 0);
    }
    else {
        upper_root_bound = max;
        upper_root_bound_function_value = fctn(max) - value;
    }
    if (min === null) {
        lower_root_bound = -1;
        do {
            lower_root_bound = -2 * Math.abs(lower_root_bound);
            lower_root_bound_function_value = fctn(lower_root_bound) - value;
        } while (lower_root_bound_function_value > 0);
    }
    else {
        lower_root_bound = min;
        lower_root_bound_function_value = fctn(min) - value;
    }
    oldX = (upper_root_bound + lower_root_bound) / 2;
    do {
        fOfOldX = fctn(oldX) - value;
        if (fOfOldX > 0) {
            upper_root_bound = oldX;
            upper_root_bound_function_value = fOfOldX;
        }
        else {
            lower_root_bound = oldX;
            lower_root_bound_function_value = fOfOldX;
        }
        x = (upper_root_bound + lower_root_bound) / 2;
        approximateRelativeError = Math.abs(x - oldX) / Math.abs(value);
        oldX = x;
        iterations++;
    } while (approximateRelativeError >= RELATIVE_ERROR_TOLERANCE
        && iterations < MAX_ITERATIONS);
    return x;
}
exports.bisection = bisection;
function discreteQuantileFind(simplifiedCDF, p, max, min, initialEstimate = 0, lowerTail = true) {
    if (max === null) {
        // find a value of max where cdf(max) >= p for lowerTail === true and cdf(max) <= p
        // for lowerTail === false
        let offset = 0.5;
        let cdfVal;
        do {
            offset *= 2;
            max = initialEstimate + offset;
            cdfVal = simplifiedCDF(max);
            if ((cdfVal < p && lowerTail) || (cdfVal > p && !lowerTail)) {
                if (min === null || min < max) {
                    min = max;
                }
            }
            else {
                break;
            }
        } while (true);
    }
    if (min === null) {
        // find a value of min where cdf(min) < p for lowerTail === true and cdf(min) > p
        // for lowerTail === true
        let offset = 0.5;
        let cdfVal;
        do {
            offset *= 2;
            min = initialEstimate - offset;
            cdfVal = simplifiedCDF(min);
        } while ((cdfVal >= p && lowerTail) || (cdfVal <= p && !lowerTail));
    }
    // check that min doesn't satisfy requirements
    let cdfMin = simplifiedCDF(min);
    if ((cdfMin >= p && lowerTail) || (cdfMin <= p && !lowerTail)) {
        return min;
    }
    let center;
    let centerFloor;
    let centerCeil;
    let maxMinAve;
    while (max - min > 1) {
        maxMinAve = (max + min) / 2;
        centerFloor = Math.floor(maxMinAve);
        centerCeil = Math.ceil(maxMinAve);
        if (centerFloor === min) {
            if (centerCeil === max) {
                break;
            }
            center = centerCeil;
        }
        else {
            center = centerFloor;
        }
        let cdfValCenter = simplifiedCDF(center);
        if ((cdfValCenter >= p && lowerTail) || (cdfValCenter <= p && !lowerTail)) {
            max = center;
        }
        else {
            min = center;
        }
    }
    return max;
}
exports.discreteQuantileFind = discreteQuantileFind;

},{}],15:[function(require,module,exports){
"use strict";
const gamma = require("./gamma");
const beta = require("./beta");
const rf = require("./rootFind");
const async_1 = require("./async");
const continuedFractionSolver_1 = require("./continuedFractionSolver");
const random_1 = require("./random");
// This import and then renaming of imports is necessary to allow the async module to
// correctly generate web worker scripts.
const lnGamma = gamma.lnGamma;
const incompleteBeta = beta.incompleteBeta;
const rootFind = rf.rootFind;
function pdfSync(x, degreesOfFreedom) {
    const lnCoefficientNumerator = lnGamma((degreesOfFreedom + 1) / 2);
    const lnCoefficientDenominator = ((1 / 2) * Math.log(degreesOfFreedom * Math.PI)) + lnGamma(degreesOfFreedom / 2);
    const lnCoefficient = lnCoefficientNumerator - lnCoefficientDenominator;
    const lnBase = Math.log(1 + ((x * x) / degreesOfFreedom));
    const exponent = -(degreesOfFreedom + 1) / 2;
    return Math.exp(lnCoefficient + (exponent * lnBase));
}
exports.pdfSync = pdfSync;
function pdf(x, degreesOfFreedom) {
    return async_1.asyncGen([beta.lnBeta, gamma.lnGamma], pdfSync, [x, degreesOfFreedom]);
}
exports.pdf = pdf;
function cdfSync(x, degreesOfFreedom, lowerTail = true) {
    const incompleteBetaEval = incompleteBeta(degreesOfFreedom / (degreesOfFreedom + x * x), degreesOfFreedom / 2, 1 / 2);
    if ((x >= 0 && lowerTail) || (x < 0 && !lowerTail)) {
        return 1 - incompleteBetaEval / 2;
    }
    else {
        return incompleteBetaEval / 2;
    }
}
exports.cdfSync = cdfSync;
function cdf(x, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta
    ], cdfSync, [x, degreesOfFreedom, lowerTail]);
}
exports.cdf = cdf;
function quantileSync(p, degreesOfFreedom, lowerTail = true) {
    function f(val) {
        return cdfSync(val, degreesOfFreedom);
    }
    function fPrime(val) {
        if (lowerTail) {
            return pdfSync(val, degreesOfFreedom);
        }
        else {
            return -pdfSync(val, degreesOfFreedom);
        }
    }
    if (p === 0) {
        if (lowerTail) {
            return Number.NEGATIVE_INFINITY;
        }
        else {
            return Number.POSITIVE_INFINITY;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return Number.POSITIVE_INFINITY;
        }
        else {
            return Number.NEGATIVE_INFINITY;
        }
    }
    else {
        return rootFind(f, fPrime, p, 0, null, null);
    }
}
exports.quantileSync = quantileSync;
function quantile(p, degreesOfFreedom, lowerTail = true) {
    return async_1.asyncGen([
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ], quantileSync, [p, degreesOfFreedom, lowerTail]);
}
exports.quantile = quantile;
function randomSync(n, degreesOfFreedom, seed, randoms) {
    return random_1.randSync(n, quantileSync, [degreesOfFreedom], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, degreesOfFreedom, seed) {
    return random_1.rand(n, quantileSync, [degreesOfFreedom], seed, [
        rf.newton,
        rf.bisection,
        rootFind,
        beta.lnBeta,
        gamma.lnGamma,
        continuedFractionSolver_1.continuedFractionSolver,
        beta.d,
        beta.continuedFraction,
        beta.lnIncompleteBeta,
        beta.incompleteBeta,
        pdfSync,
        cdfSync
    ]);
}
exports.random = random;

},{"./async":1,"./beta":2,"./continuedFractionSolver":5,"./gamma":8,"./random":13,"./rootFind":14}],16:[function(require,module,exports){
"use strict";
const random_1 = require("./random");
"use strict";
function pdfSync(x, lowerSupportBound, upperSupportBound) {
    if (x < lowerSupportBound || x > upperSupportBound) {
        return 0;
    }
    else {
        return 1 / (upperSupportBound - lowerSupportBound);
    }
}
exports.pdfSync = pdfSync;
function pdf(x, lowerSupportBound, upperSupportBound) {
    return Promise.resolve(pdfSync(x, lowerSupportBound, upperSupportBound));
}
exports.pdf = pdf;
function cdfSync(x, lowerSupportBound, upperSupportBound, lowerTail = true) {
    if (x < lowerSupportBound) {
        if (lowerTail) {
            return 0;
        }
        else {
            return 1;
        }
    }
    else if (x > upperSupportBound) {
        if (lowerTail) {
            return 1;
        }
        else {
            return 0;
        }
    }
    else {
        if (lowerTail) {
            return (x - lowerSupportBound) / (upperSupportBound - lowerSupportBound);
        }
        else {
            return (upperSupportBound - x) / (upperSupportBound - lowerSupportBound);
        }
    }
}
exports.cdfSync = cdfSync;
function cdf(x, lowerSupportBound, upperSupportBound, lowerTail = true) {
    return Promise.resolve(cdfSync(x, lowerSupportBound, upperSupportBound, lowerTail));
}
exports.cdf = cdf;
function quantileSync(p, lowerSupportBound, upperSupportBound, lowerTail = true) {
    if (p === 0) {
        if (lowerTail) {
            return lowerSupportBound;
        }
        else {
            return upperSupportBound;
        }
    }
    else if (p === 1) {
        if (lowerTail) {
            return upperSupportBound;
        }
        else {
            return lowerSupportBound;
        }
    }
    else {
        if (lowerTail) {
            return (p * (upperSupportBound - lowerSupportBound)) + lowerSupportBound;
        }
        else {
            return upperSupportBound - (p * (upperSupportBound - lowerSupportBound));
        }
    }
}
exports.quantileSync = quantileSync;
function quantile(p, lowerSupportBound, upperSupportBound, lowerTail = true) {
    return Promise.resolve(quantileSync(p, lowerSupportBound, upperSupportBound, lowerTail));
}
exports.quantile = quantile;
function randomSync(n, lowerSupportBound, upperSupportBound, seed, randoms) {
    return random_1.randSync(n, quantileSync, [lowerSupportBound, upperSupportBound], seed, randoms);
}
exports.randomSync = randomSync;
function random(n, lowerSupportBound, upperSupportBound, seed, randoms) {
    return random_1.rand(n, quantileSync, [lowerSupportBound, upperSupportBound], seed, []);
}
exports.random = random;

},{"./random":13}],17:[function(require,module,exports){
"use strict";
const _normal = require("./impls/normal");
const studentsT = require("./impls/studentsT");
const chiSquared = require("./impls/chiSquared");
const fDist = require("./impls/fDist");
const binom = require("./impls/binomial");
const _poisson = require("./impls/poisson");
const hypergeo = require("./impls/hypergeometric");
const _gamma = require("./impls/gamma");
const exp = require("./impls/exponential");
const _uniform = require("./impls/uniform");
const _beta = require("./impls/beta");
exports.uniform = {
    pdf: function (x, lowerSupportBound, upperSupportBound) {
        return _uniform.pdf(x, lowerSupportBound, upperSupportBound);
    },
    cdf: function (x, lowerSupportBound, upperSupportBound, lowerTail = true) {
        return _uniform.cdf(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    quantile: function (x, lowerSupportBound, upperSupportBound, lowerTail = true) {
        return _uniform.quantile(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    random: function (n, lowerSupportBound, upperSupportBound, seed) {
        return _uniform.random(n, lowerSupportBound, upperSupportBound, seed);
    },
    pdfSync: function (x, lowerSupportBound, upperSupportBound) {
        return _uniform.pdfSync(x, lowerSupportBound, upperSupportBound);
    },
    cdfSync: function (x, lowerSupportBound, upperSupportBound, lowerTail = true) {
        return _uniform.cdfSync(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    quantileSync: function (x, lowerSupportBound, upperSupportBound, lowerTail = true) {
        return _uniform.quantileSync(x, lowerSupportBound, upperSupportBound, lowerTail);
    },
    randomSync: function (n, lowerSupportBound, upperSupportBound, seed) {
        return _uniform.randomSync(n, lowerSupportBound, upperSupportBound, seed);
    }
};
exports.normal = {
    pdf: function (x, mu, sigma) {
        return _normal.pdf(x, mu, sigma);
    },
    cdf: function (x, mu, sigma, lowerTail = true) {
        return _normal.cdf(x, mu, sigma, lowerTail);
    },
    quantile: function (p, mu, sigma, lowerTail = true) {
        return _normal.quantile(p, mu, sigma, lowerTail);
    },
    random: function (n, mu, sigma, seed) {
        return _normal.random(n, mu, sigma, seed);
    },
    pdfSync: function (x, mu, sigma) {
        return _normal.pdfSync(x, mu, sigma);
    },
    cdfSync: function (x, mu, sigma, lowerTail = true) {
        return _normal.cdfSync(x, mu, sigma, lowerTail);
    },
    quantileSync: function (p, mu, sigma, lowerTail = true) {
        return _normal.quantileSync(p, mu, sigma, lowerTail);
    },
    randomSync: function (n, mu, sigma, seed) {
        return _normal.randomSync(n, mu, sigma, seed);
    },
};
exports.t = {
    pdf: function (x, degreesOfFreedom) {
        return studentsT.pdf(x, degreesOfFreedom);
    },
    cdf: function (x, degreesOfFreedom, lowerTail = true) {
        return studentsT.cdf(x, degreesOfFreedom, lowerTail);
    },
    quantile: function (p, degreesOfFreedom, lowerTail = true) {
        return studentsT.quantile(p, degreesOfFreedom, lowerTail);
    },
    random: function (n, degreesOfFreedom, seed) {
        return studentsT.random(n, degreesOfFreedom, seed);
    },
    pdfSync: function (x, degreesOfFreedom) {
        return studentsT.pdfSync(x, degreesOfFreedom);
    },
    cdfSync: function (x, degreesOfFreedom, lowerTail = true) {
        return studentsT.cdfSync(x, degreesOfFreedom, lowerTail);
    },
    quantileSync: function (p, degreesOfFreedom, lowerTail = true) {
        return studentsT.quantileSync(p, degreesOfFreedom, lowerTail);
    },
    randomSync: function (n, degreesOfFreedom, seed) {
        return studentsT.randomSync(n, degreesOfFreedom, seed);
    }
};
exports.chi2 = {
    pdf: function (x, degreesOfFreedom) {
        return chiSquared.pdf(x, degreesOfFreedom);
    },
    cdf: function (x, degreesOfFreedom, lowerTail = true) {
        return chiSquared.cdf(x, degreesOfFreedom, lowerTail);
    },
    quantile: function (p, degreesOfFreedom, lowerTail = true) {
        return chiSquared.quantile(p, degreesOfFreedom, lowerTail);
    },
    random: function (n, degreesOfFreedom, seed) {
        return chiSquared.random(n, degreesOfFreedom, seed);
    },
    pdfSync: function (x, degreesOfFreedom) {
        return chiSquared.pdfSync(x, degreesOfFreedom);
    },
    cdfSync: function (x, degreesOfFreedom, lowerTail = true) {
        return chiSquared.cdfSync(x, degreesOfFreedom, lowerTail);
    },
    quantileSync: function (p, degreesOfFreedom, lowerTail = true) {
        return chiSquared.quantileSync(p, degreesOfFreedom, lowerTail);
    },
    randomSync: function (n, degreesOfFreedom, seed) {
        return chiSquared.randomSync(n, degreesOfFreedom, seed);
    }
};
exports.F = {
    pdf: function (x, dof1, dof2) {
        return fDist.pdf(x, dof1, dof2);
    },
    cdf: function (x, dof1, dof2, lowerTail = true) {
        return fDist.cdf(x, dof1, dof2, lowerTail);
    },
    quantile: function (p, dof1, dof2, lowerTail = true) {
        return fDist.quantile(p, dof1, dof2, lowerTail);
    },
    random: function (n, dof1, dof2, seed) {
        return fDist.random(n, dof1, dof2, seed);
    },
    pdfSync: function (x, dof1, dof2) {
        return fDist.pdfSync(x, dof1, dof2);
    },
    cdfSync: function (x, dof1, dof2, lowerTail = true) {
        return fDist.cdfSync(x, dof1, dof2, lowerTail);
    },
    quantileSync: function (p, dof1, dof2, lowerTail = true) {
        return fDist.quantileSync(p, dof1, dof2, lowerTail);
    },
    randomSync: function (n, dof1, dof2, seed) {
        return fDist.randomSync(n, dof1, dof2, seed);
    }
};
exports.exponential = {
    pdf: function (x, lambda) {
        return exp.pdf(x, lambda);
    },
    cdf: function (x, lambda, lowerTail = true) {
        return exp.cdf(x, lambda, lowerTail);
    },
    quantile: function (p, lambda, lowerTail = true) {
        return exp.quantile(p, lambda, lowerTail);
    },
    random: function (n, lambda, seed) {
        return exp.random(n, lambda, seed);
    },
    pdfSync: function (x, lambda) {
        return exp.pdfSync(x, lambda);
    },
    cdfSync: function (x, lambda, lowerTail = true) {
        return exp.cdfSync(x, lambda, lowerTail);
    },
    quantileSync: function (p, lambda, lowerTail = true) {
        return exp.quantileSync(p, lambda, lowerTail);
    },
    randomSync: function (n, lambda, seed) {
        return exp.randomSync(n, lambda, seed);
    }
};
exports.gamma = {
    pdf: function (x, shape, scale) {
        return _gamma.pdf(x, shape, scale);
    },
    cdf: function (x, shape, scale, lowerTail = true) {
        return _gamma.cdf(x, shape, scale, lowerTail);
    },
    quantile: function (p, shape, scale, lowerTail = true) {
        return _gamma.quantile(p, shape, scale, lowerTail);
    },
    random: function (n, shape, scale, seed) {
        return _gamma.random(n, shape, scale, seed);
    },
    pdfSync: function (x, shape, scale) {
        return _gamma.pdfSync(x, shape, scale);
    },
    cdfSync: function (x, shape, scale, lowerTail = true) {
        return _gamma.cdfSync(x, shape, scale, lowerTail);
    },
    quantileSync: function (p, shape, scale, lowerTail = true) {
        return _gamma.quantileSync(p, shape, scale, lowerTail);
    },
    randomSync: function (n, shape, scale, seed) {
        return _gamma.randomSync(n, shape, scale, seed);
    }
};
exports.beta = {
    pdf: function (x, alpha, beta) {
        return _beta.pdf(x, alpha, beta);
    },
    cdf: function (x, alpha, beta, lowerTail = true) {
        return _beta.cdf(x, alpha, beta, lowerTail);
    },
    quantile: function (x, alpha, beta, lowerTail = true) {
        return _beta.quantile(x, alpha, beta, lowerTail);
    },
    random: function (n, alpha, beta, seed) {
        return _beta.random(n, alpha, beta, seed);
    },
    pdfSync: function (x, alpha, beta) {
        return _beta.pdfSync(x, alpha, beta);
    },
    cdfSync: function (x, alpha, beta, lowerTail = true) {
        return _beta.cdfSync(x, alpha, beta, lowerTail);
    },
    quantileSync: function (x, alpha, beta, lowerTail = true) {
        return _beta.quantileSync(x, alpha, beta, lowerTail);
    },
    randomSync: function (n, alpha, beta, seed) {
        return _beta.randomSync(n, alpha, beta, seed);
    }
};
exports.binomial = {
    pdf: function (k, trials, probSuccess) {
        return binom.pmf(k, trials, probSuccess);
    },
    cdf: function (k, trials, probSuccess, lowerTail = true) {
        return binom.cdf(k, trials, probSuccess, lowerTail);
    },
    quantile: function (p, trials, probSuccess, lowerTail = true) {
        return binom.quantile(p, trials, probSuccess, lowerTail);
    },
    random: function (n, trials, probSuccess, seed) {
        return binom.random(n, trials, probSuccess, seed);
    },
    pdfSync: function (k, trials, probSuccess) {
        return binom.pmfSync(k, trials, probSuccess);
    },
    cdfSync: function (k, trials, probSuccess, lowerTail = true) {
        return binom.cdfSync(k, trials, probSuccess, lowerTail);
    },
    quantileSync: function (p, trials, probSuccess, lowerTail = true) {
        return binom.quantileSync(p, trials, probSuccess, lowerTail);
    },
    randomSync: function (n, trials, probSuccess, seed) {
        return binom.randomSync(n, trials, probSuccess, seed);
    }
};
exports.poisson = {
    pdf: function (k, lambda) {
        return _poisson.pmf(k, lambda);
    },
    cdf: function (k, lambda, lowerTail = true) {
        return _poisson.cdf(k, lambda, lowerTail);
    },
    quantile: function (p, lambda, lowerTail = true) {
        return _poisson.quantile(p, lambda, lowerTail);
    },
    random: function (n, lambda, seed) {
        return _poisson.random(n, lambda, seed);
    },
    pdfSync: function (k, lambda) {
        return _poisson.pmfSync(k, lambda);
    },
    cdfSync: function (k, lambda, lowerTail = true) {
        return _poisson.cdfSync(k, lambda, lowerTail);
    },
    quantileSync: function (p, lambda, lowerTail = true) {
        return _poisson.quantileSync(p, lambda, lowerTail);
    },
    randomSync: function (n, lambda, seed) {
        return _poisson.randomSync(n, lambda, seed);
    }
};
exports.hypergeometric = {
    pdf: function (sampleSuccesses, draws, successPop, totalPop) {
        return hypergeo.pmf(sampleSuccesses, draws, successPop, totalPop);
    },
    cdf: function (sampleSuccesses, draws, successPop, totalPop, lowerTail = true) {
        return hypergeo.cdf(sampleSuccesses, draws, successPop, totalPop, lowerTail);
    },
    quantile: function (p, draws, successPop, totalPop, lowerTail = true) {
        return hypergeo.quantile(p, draws, successPop, totalPop, lowerTail);
    },
    random: function (n, draws, successPop, totalPop, seed) {
        return hypergeo.random(n, draws, successPop, totalPop, seed);
    },
    pdfSync: function (sampleSuccesses, draws, successPop, totalPop) {
        return hypergeo.pmfSync(sampleSuccesses, draws, successPop, totalPop);
    },
    cdfSync: function (sampleSuccesses, draws, successPop, totalPop, lowerTail = true) {
        return hypergeo.cdfSync(sampleSuccesses, draws, successPop, totalPop, lowerTail);
    },
    quantileSync: function (p, draws, successPop, totalPop, lowerTail = true) {
        return hypergeo.quantileSync(p, draws, successPop, totalPop, lowerTail);
    },
    randomSync: function (n, draws, successPop, totalPop, seed) {
        return hypergeo.randomSync(n, draws, successPop, totalPop, seed);
    }
};

},{"./impls/beta":2,"./impls/binomial":3,"./impls/chiSquared":4,"./impls/exponential":6,"./impls/fDist":7,"./impls/gamma":8,"./impls/hypergeometric":9,"./impls/normal":10,"./impls/poisson":11,"./impls/studentsT":15,"./impls/uniform":16}],18:[function(require,module,exports){
(function (process,__filename){

/**
 * Module dependencies.
 */

var fs = require('fs')
  , path = require('path')
  , join = path.join
  , dirname = path.dirname
  , exists = fs.existsSync || path.existsSync
  , defaults = {
        arrow: process.env.NODE_BINDINGS_ARROW || '  '
      , compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled'
      , platform: process.platform
      , arch: process.arch
      , version: process.versions.node
      , bindings: 'bindings.node'
      , try: [
          // node-gyp's linked version in the "build" dir
          [ 'module_root', 'build', 'bindings' ]
          // node-waf and gyp_addon (a.k.a node-gyp)
        , [ 'module_root', 'build', 'Debug', 'bindings' ]
        , [ 'module_root', 'build', 'Release', 'bindings' ]
          // Debug files, for development (legacy behavior, remove for node v0.9)
        , [ 'module_root', 'out', 'Debug', 'bindings' ]
        , [ 'module_root', 'Debug', 'bindings' ]
          // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        , [ 'module_root', 'out', 'Release', 'bindings' ]
        , [ 'module_root', 'Release', 'bindings' ]
          // Legacy from node-waf, node <= 0.4.x
        , [ 'module_root', 'build', 'default', 'bindings' ]
          // Production "Release" buildtype binary (meh...)
        , [ 'module_root', 'compiled', 'version', 'platform', 'arch', 'bindings' ]
        ]
    }

/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */

function bindings (opts) {

  // Argument surgery
  if (typeof opts == 'string') {
    opts = { bindings: opts }
  } else if (!opts) {
    opts = {}
  }
  opts.__proto__ = defaults

  // Get the module root
  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName())
  }

  // Ensure the given bindings name ends with .node
  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node'
  }

  var tries = []
    , i = 0
    , l = opts.try.length
    , n
    , b
    , err

  for (; i<l; i++) {
    n = join.apply(null, opts.try[i].map(function (p) {
      return opts[p] || p
    }))
    tries.push(n)
    try {
      b = opts.path ? require.resolve(n) : require(n)
      if (!opts.path) {
        b.path = n
      }
      return b
    } catch (e) {
      if (!/not find/i.test(e.message)) {
        throw e
      }
    }
  }

  err = new Error('Could not locate the bindings file. Tried:\n'
    + tries.map(function (a) { return opts.arrow + a }).join('\n'))
  err.tries = tries
  throw err
}
module.exports = exports = bindings


/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName (calling_file) {
  var origPST = Error.prepareStackTrace
    , origSTL = Error.stackTraceLimit
    , dummy = {}
    , fileName

  Error.stackTraceLimit = 10

  Error.prepareStackTrace = function (e, st) {
    for (var i=0, l=st.length; i<l; i++) {
      fileName = st[i].getFileName()
      if (fileName !== __filename) {
        if (calling_file) {
            if (fileName !== calling_file) {
              return
            }
        } else {
          return
        }
      }
    }
  }

  // run the 'prepareStackTrace' function above
  Error.captureStackTrace(dummy)
  dummy.stack

  // cleanup
  Error.prepareStackTrace = origPST
  Error.stackTraceLimit = origSTL

  return fileName
}

/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */

exports.getRoot = function getRoot (file) {
  var dir = dirname(file)
    , prev
  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd()
    }
    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir
    }
    if (prev === dir) {
      // Got to the top
      throw new Error('Could not find module root given file: "' + file
                    + '". Do you have a `package.json` file? ')
    }
    // Try the parent dir next
    prev = dir
    dir = join(dir, '..')
  }
}

}).call(this,require('_process'),"/node_modules/bindings/bindings.js")
},{"_process":21,"fs":19,"path":20}],19:[function(require,module,exports){

},{}],20:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":21}],21:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],22:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":23,"./lib/tychei":24,"./lib/xor128":25,"./lib/xor4096":26,"./lib/xorshift7":27,"./lib/xorwow":28,"./seedrandom":29}],23:[function(require,module,exports){
// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],24:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],25:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],26:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1104.3115.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],27:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],28:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],29:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
    var out = new Uint8Array(width);
    (global.crypto || global.msCrypto).getRandomValues(out);
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":undefined}],30:[function(require,module,exports){
var WebWorkerThreads = require('bindings')('WebWorkerThreads');
 
module.exports = WebWorkerThreads;

},{"bindings":18}]},{},[17])(17)
});